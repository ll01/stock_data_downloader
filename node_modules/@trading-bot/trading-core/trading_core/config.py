"""
Pydantic configuration models for trading applications.

This module contains Pydantic models for configuration:
- ServerConfig: Configuration for server components
- DataSourceConfig: Configuration for data sources
- ExchangeConfig: Configuration for exchange connections
- StrategyConfig: Configuration for trading strategies
- MonitoringConfig: Configuration for monitoring components
- AppConfig: Main configuration class that combines all configurations
"""

from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Dict, List, Optional, Union
from enum import Enum
import re


class DataSourceType(str, Enum):
    """Enum for data source types."""
    YAHOO = "yahoo"
    BINANCE = "binance"
    HYPERLIQUID = "hyperliquid"
    BACKTEST = "backtest"


class ServerConfig(BaseModel):
    """
    Configuration for server components.
    
    Attributes:
        host: The server host address
        port: The server port
        debug: Whether to run in debug mode
        log_level: The logging level
    """
    host: str = "0.0.0.0"
    port: int = 8000
    debug: bool = False
    log_level: str = "INFO"
    
    @field_validator('log_level')
    @classmethod
    def validate_log_level(cls, v):
        """Validate that the log level is valid."""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if v not in valid_levels:
            raise ValueError(f"Log level must be one of {valid_levels}")
        return v


class DataSourceConfig(BaseModel):
    """
    Configuration for data sources.
    
    Attributes:
        type: The type of data source
        tickers: List of ticker symbols
        interval: The data interval (e.g., '1d', '4h', '30m')
        api_key: Optional API key for authenticated sources
        api_secret: Optional API secret for authenticated sources
        backtest_file: Optional path to backtest data file
    """
    type: DataSourceType
    tickers: List[str]
    interval: str = "1d"
    api_key: Optional[str] = None
    api_secret: Optional[str] = None
    backtest_file: Optional[str] = None
    
    @field_validator('interval')
    @classmethod
    def validate_interval(cls, v):
        """Validate that the interval is in the correct format."""
        if not re.match(r'^\d+[mhdwM]$', v):
            raise ValueError("Interval must be in format like '1m', '4h', '1d', '1w', '1M'")
        return v


class ExchangeConfig(BaseModel):
    """
    Configuration for exchange connections.
    
    Attributes:
        name: The exchange name
        api_key: Optional API key for authenticated access
        api_secret: Optional API secret for authenticated access
        testnet: Whether to use the testnet/sandbox environment
        rate_limit: Rate limit in requests per second
    """
    name: str
    api_key: Optional[str] = None
    api_secret: Optional[str] = None
    testnet: bool = True
    rate_limit: int = 5  # requests per second
    
    @field_validator('rate_limit')
    @classmethod
    def validate_rate_limit(cls, v):
        """Validate that the rate limit is positive."""
        if v <= 0:
            raise ValueError("Rate limit must be positive")
        return v


class StrategyConfig(BaseModel):
    """
    Configuration for trading strategies.
    
    Attributes:
        name: The strategy name
        parameters: Dictionary of strategy parameters
    """
    name: str
    parameters: Dict[str, Union[str, int, float, bool]]


class MonitoringConfig(BaseModel):
    """
    Configuration for monitoring components.
    
    Attributes:
        zmq_host: The ZMQ host address
        zmq_port: The ZMQ port for monitoring
        enabled: Whether monitoring is enabled
        log_trades: Whether to log trades
        log_stats_interval: Interval for logging statistics in seconds
    """
    zmq_host: str = "localhost"
    zmq_port: int = 5557
    enabled: bool = True
    log_trades: bool = True
    log_stats_interval: int = 60  # seconds
    
    @field_validator('zmq_port')
    @classmethod
    def validate_zmq_port(cls, v):
        """Validate that the ZMQ port is in a valid range."""
        if not (1024 <= v <= 65535):
            raise ValueError("ZMQ port must be between 1024 and 65535")
        return v
    
    @field_validator('log_stats_interval')
    @classmethod
    def validate_log_stats_interval(cls, v):
        """Validate that the log stats interval is positive."""
        if v <= 0:
            raise ValueError("Log stats interval must be positive")
        return v


class AppConfig(BaseModel):
    """
    Main configuration class that combines all configurations.
    
    Attributes:
        server: Server configuration
        data_sources: Dictionary of data source configurations
        exchanges: Dictionary of exchange configurations
        strategies: Dictionary of strategy configurations
        monitoring: Monitoring configuration
    """
    server: ServerConfig
    data_sources: Dict[str, DataSourceConfig]
    exchanges: Dict[str, ExchangeConfig]
    strategies: Dict[str, StrategyConfig]
    monitoring: MonitoringConfig
    
    model_config = ConfigDict(extra="forbid")  # Forbid extra attributes